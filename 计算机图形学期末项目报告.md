# 计算机图形学期末项目报告

## 一.项目描述（lmj）

//简单描述项目完成效果

//小组分工

| 姓名 | 学号 | 担任工作 |
| :--: | :--: | :------: |
|      |      |          |
|      |      |          |
|      |      |          |
|      |      |          |

## 二. 粒子系统（lws,lmj）

#### (一)粒子与发射器类

//每一份部分格式如下：

//简单介绍该部分作用

```cpp
//核心代码
//......
```

//简单解释可以实现的效果，某些部分可以贴上效果图

##### 粒子类

|参数|类型|描述|
|--|--|--|
|position|vec3|粒子在世界坐标系下的位置|
|color|vec4|粒子具有的颜色以及透明度(rgba)|
|size|float|着色器中赋值给glPointSize的值, 代表粒子的大小, 实际中还会除以与摄像机的距离|
|velocity|vec3|粒子当前帧具有的速度, 包括大小和方向|
|lifetime|int64_t|粒子剩余的存活时间, 单位为毫秒|
|totallifetime|int64_t|粒子总共具有的存活时间, 该参数用于实现对粒子颜色, 速度等参数的特殊更新操作|

```c++
struct Particle {
    glm::vec3 position;
    glm::vec4 color;
    float size;
    glm::vec3 velocity;
    int64_t lifetime;
    int64_t totallifetime;
    inline bool alive() { return lifetime > 0; }
};
```

##### 发射器接口

接口 `EmitParticle` 用于对粒子设置不同的初始参数, 本程序中预设了三种发射器: 直线型, 圆型, 球型. 使用这三种发射器配合一些特殊参数的设置可以满足几乎所有烟花类型的创建要求.

```c++
class Emitter {
public:
    virtual void EmitParticle(Particle& particle) = 0;
public:

    /**********************
    *      必要参数        *
    **********************/

    glm::vec3 emitter_center;                // 粒子产生的中心位置, 发射器的中心
    glm::vec4 particle_color;                // 发射器产生的粒子的颜色
    float particle_size;                     // 粒子大小
    uint64_t particle_lifetime;              // 粒子生命周期
    float particle_initial_velocity;         // 粒子初速度
    glm::vec3 particle_initial_direction;    // 发射粒子的方向, 设置时会normalize
    glm::vec3 particle_initial_acceleration; // 发射粒子的加速度
    uint64_t emission_delta_time;            // 发射粒子的时间间隔
    unsigned int texture;                    // 粒子使用的纹理
    glm::vec3 emitter_velocity;              // 发射器的速度
    glm::vec3 emitter_acceleration;          // 发射器的加速度
    EmitterType emitter_type;                // 发射器类型, 见 EmitterType 定义

    /**********************
    *      可选选项        *
    **********************/
    float emitter_radial_acceleration;       // 粒子发射器径向加速度
    float lifetime_tolerance;                // 粒子生命周期误差范围 相对于生命周期的百分比
}
```

**发射器类型**

**线型发射器**

额外添加散度参数, 描述粒子在发射器发射方向上的随机偏离程度, 并限定范围从 0 到 1, 其中 0 代表完全不偏离初始方向, 1 代表完全随机方向.

对于设置的散度 `divergence`, 判断它是否为 0, 如果为 0 则直接用粒子发射器的发射方向乘以发射器发射粒子的速度作为该粒子的初速度, 否则产生一个从发射方向原点指向一个半径为散度的球面上随机点的方向向量作为粒子的初始方向, 并据此计算初速度. 

```c++
if (divergence == 0.0f) particle.velocity = particle_initial_velocity * particle_initial_direction;
else particle.velocity = particle_initial_velocity * glm::normalize(particle_initial_direction - 2.0f * divergence * glm::normalize(glm::sphericalRand(divergence)));
```

**圆型发射器**

额外添加半径与方向类型参数, 半径是发射器产生的粒子所在的圆周的半径(只会在圆周上产生, 圆的内部不会产生), 方向类型分为 `outer` 和 `diret` 两种, `outer` 会以圆心向外随机方向发射处于圆平面内的粒子, `diret` 会产生沿发射器发射方向运动的粒子. 发射平面是与粒子发射器发射方向正交的平面, 通过在粒子发射器中心位置建立坐标系获得该平面, 下面是建立坐标系的代码:

```c++
// 旋转轴
glm::vec3 axis = particle_initial_direction;
// 与 axis 正交的一个速度向量 src
glm::vec3 src = axis;
if (src.x != 0) { src.y += 1; src = particle_initial_velocity * glm::normalize(glm::cross(src, particle_initial_direction)); }
else if (src.y != 0) { src.z += 1; src = particle_initial_velocity * glm::normalize(glm::cross(src, particle_initial_direction)); }
else if (src.z != 0) { src.x += 1; src = particle_initial_velocity * glm::normalize(glm::cross(src, particle_initial_direction)); }
else {
    // 如果速度为 0 默认在 x-z 平面生成圆
    src = particle_initial_velocity * glm::vec3(1.0f, 0.0f, 1.0f);
    axis = glm::vec3(0.0f, 1.0f, 0.0f);
}
// 第二个正交向量
glm::vec3 src2 = glm::normalize(glm::cross(axis, src));
/*
    以上建立了一个以发射器为原点的单位正交坐标系(axis - src- src2)
*/
// 根据方向类型生成速度
// 随机线性组合 src 与 src2 得到一个正交于 axis 的随机方向向量
// velocity 为指向圆心外的单位速度 或者 为0
glm::vec3 velocity = glm::normalize(static_cast<float>(glm::linearRand(-1.0, 1.0)) * src2 + static_cast<float>(glm::linearRand(-1.0, 1.0)) * src);
if (direction_type == DirectionType::Outer) {
    particle.velocity = particle_initial_velocity*velocity;
}
else {
    particle.velocity = particle_initial_velocity * particle_initial_direction;
}
// radius * velocity 限定偏移在圆周上或圆心
particle.position = emitter_center + radius * velocity;
particle.color = particle_color;
particle.size = particle_size;
```

**球型发射器**

额外参数与圆型一致, 且含义类似, 这里不再赘述, 实现思路见代码:
```c++
// 随机生成朝向球心外方向的速度
if (direction_type == DirectionType::Outer) particle.velocity = particle_initial_velocity * glm::normalize(glm::sphericalRand(1.0f));
else particle.velocity = particle_initial_velocity * particle_initial_direction;
// 空间中产生随机方向
// 然后限定偏移在半径上
particle.position = emitter_center + radius * glm::normalize(glm::sphericalRand(1.0f));
particle.color = particle_color;
particle.size = particle_size;
```

#### (二)粒子发射器



#### (三) …………



#### (四)粒子渲染类



## 三. 世界构建 (ljr,xr)

#### (一) 天空盒及地面的搭建



#### (二) 相机实现视角移动（简单提一下即可）



#### (三) 烟花模型的构建与放置



#### (四)……



## 四. 烟花实现 

#### (一)泛光（lmj）



#### (二)光照bling phone（ljr，xr）



#### (三) 烟花声音（lmj，lws）



#### (四)各种烟花管理器和各种类烟花？（lws）

//可展示效果



## 五. 总结（lmj）